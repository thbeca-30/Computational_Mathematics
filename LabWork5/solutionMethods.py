import math

def firstDerivative(xy): # Метод получения первой производной при помощи интерполяции многочленом Ньютона
    temp = [] # Здесь мы храним временные значения конечных разностей
    dy = [] # Список списков для хранения значений конечных разностей
    for i in range(len(xy) - 1): # В промежуточный список заносим конечные разности 1-ого порядка
        temp.append(xy[i + 1][1] - xy[i][1]) # Считаем конечные разности
    dy.append(temp) # Заносим промежуточный список в список списков конечных разностей
    for i in range(len(xy) - 2): # На каждом i-ом шаге вычисляем значения конечных разностей нового порядка
                                 # и заносим в промежуточный список.
        temp = []  # Инициализация промежуточного списка пустым            
        for j in range(len(dy[i]) - 1):
            temp.append(dy[i][j + 1] - dy[i][j]) # Считаем конечные разности
        dy.append(temp) # Промежуточный список заносим в список списков промежуточных разностей
    result = [] # В этом списке мы храним полученные значения
    h = xy[1][0] - xy[0][0] # Считаем шаг h

    for i in xy:
        t = (i[0] - xy[0][0]) / h # Вычисляем параметр t, который зависит от h
        res = dy[0][0] # К результату прибавляем Δy0
        res += ((2.0 * t - 1.0) * dy[1][0] / math.factorial(2)) # Прибавляем к результату последующие слагаемые до Δ^5y0
        res += ((3.0 * t ** 2 - 6.0 * t + 2.0) * dy[2][0] / math.factorial(3))
        res += ((4.0 * t ** 3 - 18.0 * t ** 2 + 22.0 * t - 6.0) * dy[3][0] / math.factorial(4))
        res += ((5.0 * t ** 4 - 40.0 * t ** 3 + 105.0 * t ** 2 - 100.0 * t + 24.0) * dy[4][0] / math.factorial(5))
        res /= h # Из-за того, что узлы равноотстоящие, нужно разделить результат на h
        result.append(res) # Заносим результат в список ответов
    return result


def secondDerivative(xy): # Метод получения второй производной при помощи интерполяции многочленом Ньютона
    temp = [] # Здесь мы храним временные значения конечных разностей
    dy = [] # Список списков для хранения значений конченых разностей
    for i in range(len(xy) - 1): # В промежуточный список заносим конечные разности 1-ого порядка
        temp.append(xy[i + 1][1] - xy[i][1]) # Cчитаем конечные разности
    dy.append(temp) # Промежуточный список заносим в список списков конечных разностей

    
    for i in range(len(xy) - 2):# На каждом i-ом шаге вычисляем значения конечных разностей нового порядка
                                # и заносим в промежуточный список.
        temp = [] # Инициализация промежуточного списка пустым списком
        for j in range(len(dy[i]) - 1):
            temp.append(dy[i][j + 1] - dy[i][j]) # Считаем конечные разности
        dy.append(temp) # Полученный промежуточный список заносим в список списков промежуточных разностей
    result = [] # В этом списке мы храним полученные значения
    h = xy[1][0] - xy[0][0] # Считаем шаг h
    for i in xy:
        t = (i[0] - xy[0][0]) / h # Считаем параметр t, зависящий от h 
        res = dy[1][0] # К результату прибавляем Δ^2y0
        res += ((6.0 * t - 6.0) * dy[2][0]) / math.factorial(3) # Прибавляем к результату последующие слагаемые до Δ^5y0
        res += ((12.0 * t ** 2 - 36.0 * t + 22.0) * dy[3][0]) / math.factorial(4)
        res += ((20.0 * t ** 3 - 120.0 * t ** 2 + 210.0 * t -100.0) * dy[4][0] / math.factorial(5))
        res /= (h ** 2) # Так как узлы равноотстоящие, делим полученный результат на h
        result.append(res) # Заносим результат в список ответов
    return result